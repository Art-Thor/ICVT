<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PIQNIC Orbit</title>
  <style>
    :root[data-theme="dark"] {
      --bg: #0c111b;
      --card: #111827;
      --panel: #0f172a;
      --accent: #4ade80;
      --accent2: #60a5fa;
      --border: #1f2937;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --danger: #ef4444;
      --warning: #fbbf24;
      --header-bg: rgba(17, 24, 39, 0.9);
      --table-th: #0b1221;
      --table-hover: rgba(96,165,250,0.07);
    }
    :root[data-theme="light"] {
      --bg: #f8fafc;
      --card: #ffffff;
      --panel: #f1f5f9;
      --accent: #22c55e;
      --accent2: #3b82f6;
      --border: #d4d7dd;
      --text: #0f172a;
      --muted: #475569;
      --danger: #dc2626;
      --warning: #f59e0b;
      --header-bg: #ffffff;
      --table-th: #e2e8f0;
      --table-hover: rgba(59,130,246,0.08);
    }
    * { box-sizing: border-box; }
    body { font-family: "Inter", "Segoe UI", Arial, sans-serif; margin: 0; padding: 0; background: var(--bg); color: var(--text); }
    header { background: var(--header-bg); backdrop-filter: blur(6px); padding: 14px 20px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid var(--border); }
    main { padding: 20px; max-width: 1400px; margin: 0 auto; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 18px; margin-bottom: 18px; box-shadow: 0 10px 30px rgba(0,0,0,0.12); }
    h1, h2, h3 { margin: 0 0 12px 0; font-weight: 700; }
    label { display: block; margin-bottom: 6px; color: var(--muted); font-size: 13px; text-transform: uppercase; letter-spacing: 0.02em; }
    input, select, textarea { width: 100%; padding: 11px 12px; margin-bottom: 12px; border-radius: 10px; border: 1px solid var(--border); background: var(--panel); color: var(--text); transition: border-color 0.15s ease, box-shadow 0.15s ease; }
    input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent2); box-shadow: 0 0 0 2px rgba(96,165,250,0.25); }
    textarea { resize: vertical; min-height: 180px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    button { background: var(--accent); color: #0f172a; padding: 10px 14px; border: none; border-radius: 10px; cursor: pointer; font-weight: 700; box-shadow: 0 10px 25px rgba(74,222,128,0.25); transition: transform 0.1s ease, box-shadow 0.1s ease; }
    button:hover { transform: translateY(-1px); box-shadow: 0 14px 30px rgba(74,222,128,0.35); }
    button.secondary { background: var(--accent2); color: #0f172a; box-shadow: 0 10px 25px rgba(96,165,250,0.25); }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .status { padding: 10px 12px; border-radius: 10px; background: var(--panel); border: 1px solid var(--border); margin-top: 8px; }
    .info-banner { padding: 10px 12px; border-radius: 10px; background: var(--panel); border: 1px dashed var(--border); margin: 8px 0 18px 0; font-weight: 700; display: inline-block; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px; }
    table { width: 100%; border-collapse: collapse; margin-top: 8px; border: 1px solid var(--border); }
    th, td { padding: 12px; border-bottom: 1px solid var(--border); text-align: left; }
    th { background: var(--table-th); text-transform: uppercase; letter-spacing: 0.02em; font-size: 12px; }
    tr:hover { background: var(--table-hover); cursor: pointer; }
    .table-wrap { width: 100%; overflow-x: auto; }
    .pill { display: inline-block; padding: 4px 8px; border-radius: 12px; font-size: 12px; }
    .pill.green { background: var(--accent); color: #0f172a; }
    .pill.amber { background: var(--warning); color: #0f172a; }
    .pill.red { background: var(--danger); color: #fff; }
    pre { background: var(--panel); color: #cbd5e1; padding: 12px; border-radius: 10px; border: 1px solid var(--border); overflow: auto; max-height: 280px; }
    a { color: var(--accent); }
    .hidden { display: none; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .inline { display: inline-block; margin-right: 8px; }
    .collapsible { border-radius: 14px; }
    .collapsible-head { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px; }
    .collapsible-body.collapsed { display: none; }
    .doc-layout { display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }
    .layout-row-lr { flex-direction: row; }
    .layout-row-rl { flex-direction: row-reverse; }
    .layout-col-tb { flex-direction: column; flex-wrap: nowrap; }
    .layout-col-bt { flex-direction: column-reverse; flex-wrap: nowrap; }
    .layout-col-tb .doc-pdf,
    .layout-col-bt .doc-pdf,
    .layout-col-tb .doc-fields,
    .layout-col-bt .doc-fields { flex: 1 1 auto; width: 100%; min-width: 0; }
    .doc-pdf { flex: 1 1 480px; min-width: 320px; max-height: 80vh; overflow: auto; position: relative; }
    .doc-fields { flex: 1 1 320px; min-width: 280px; max-height: 80vh; overflow: auto; }
    .zoom-controls { display: inline-flex; gap: 6px; align-items: center; background: var(--panel); border: 1px solid var(--border); border-radius: 10px; padding: 4px; }
    .legend { display:flex; gap:10px; align-items:center; flex-wrap:wrap; font-size:13px; color:var(--muted); margin:10px 0; }
	    .legend span { display:inline-flex; align-items:center; gap:6px; }
	    .legend .dot { width:12px; height:12px; border-radius:50%; display:inline-block; }
	    .legend .dot.green { background:#22c55e; }
	    .legend .dot.amber { background:#fbbf24; }
	    .legend .dot.red { background:#ef4444; }
	    .field-error { color: var(--danger); font-size: 12px; margin-top: 4px; min-height: 14px; }
	    .compact-select { max-width: 220px; min-width: 180px; width: 100%; }
	  </style>
  <script src="/static/pdf.min.js"></script>
</head>
<body>
  <header>
    <div id="navButtons" class="hidden">
      <button class="secondary" data-view="jobs">Jobs</button>
      <button class="secondary" data-view="admin">Admin</button>
    </div>
    <div style="display:flex; align-items:center; gap:12px;">
      <button id="themeToggle" class="secondary">Toggle theme</button>
      <div id="userInfo"></div>
    </div>
  </header>

  <main>
    <section id="view-login" class="card">
      <h2>Login</h2>
      <div class="grid">
        <div>
          <label>Email</label>
          <input id="loginEmail" type="email" placeholder="admin@example.com">
        </div>
        <div>
          <label>Password</label>
          <input id="loginPass" type="password" placeholder="Password">
        </div>
      </div>
      <button id="loginBtn">Sign in</button>
      <div class="status" id="loginStatus">Enter your credentials</div>
    </section>

    <section id="view-jobs" class="hidden">
      <div class="card collapsible" data-collapsible="jobsList">
        <div class="collapsible-head">
          <h2>Job list</h2>
          <button class="secondary" data-toggle="jobsList">Collapse</button>
        </div>
        <div class="collapsible-body" id="jobsBody">
          <div class="status" id="jobsStatus">Loading...</div>
          <table id="jobsTable">
            <thead>
              <tr>
                <th>Customer</th><th>Job Name</th><th>Job Type</th><th>Documents to Review</th><th>Priority</th><th>Folder prefix</th><th>Active verifiers</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
          <div class="status" id="selectedJob" class="hidden"></div>
        </div>
      </div>

      <div id="jobContext" class="info-banner hidden"></div>

      <div class="card collapsible hidden" id="uploadCard" style="margin-top:16px;" data-collapsible="upload">
        <div class="collapsible-head">
          <h3>Upload to selected job</h3>
          <button class="secondary" data-toggle="upload">Collapse</button>
        </div>
        <div class="collapsible-body" id="uploadBody">
          <div class="grid">
            <div>
              <label>Job prefix</label>
              <input id="jobFolder" type="text" readonly>
            </div>
            <div>
              <label>File (PDF/TIFF/PNG/JPG)</label>
              <input id="fileInput" type="file" accept=".pdf,.tiff,.tif,.png,.jpg,.jpeg" multiple>
            </div>
          </div>
          <button id="uploadBtn">Upload and run Textract</button>
          <div class="status" id="statusBox">Select job and file</div>
        </div>
      </div>

      <!-- documents container -->
      <div id="docsContainer"></div>

      <div class="card hidden" id="textractCard">
        <h3>Textract Result</h3>
        <div id="textractStatus"></div>
        <div id="textractData"></div>
        <div id="exportLink"></div>
        <details>
          <summary>Raw JSON</summary>
          <pre id="rawJson"></pre>
        </details>
      </div>
    </section>

    <section id="view-admin" class="hidden">
      <div class="card">
        <h2>Users</h2>
        <div class="grid">
          <div><label>Email</label><input id="userEmail" type="email" placeholder="user@example.com"></div>
          <div><label>Password</label><input id="userPass" type="password" placeholder="Password"></div>
          <div>
            <label>Role</label>
            <select id="userRole">
              <option value="verifier">verifier</option>
              <option value="viewer">viewer</option>
              <option value="admin">admin</option>
            </select>
          </div>
        </div>
        <button id="createUserBtn">Create user</button>
        <div class="status" id="usersStatus"></div>
        <table id="usersTable">
          <thead><tr><th>Email</th><th>Role</th><th>Created</th><th></th></tr></thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="card">
        <h2>Reviewer access (job folders)</h2>
        <div class="grid">
          <div>
            <label>User</label>
            <select id="accessUserSelect"></select>
          </div>
          <div>
            <label>Folders (jobs)</label>
            <div id="accessFoldersWrap" style="display:flex; flex-wrap:wrap; gap:8px; max-height:160px; overflow:auto; border:1px solid var(--border); padding:8px; border-radius:10px; background:var(--panel);"></div>
          </div>
        </div>
        <button id="createAccessBtn">Save access</button>
        <div class="status" id="accessStatus"></div>
        <table id="accessTable">
          <thead><tr><th>ID</th><th>User ID</th><th>Folder</th><th></th></tr></thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="card">
        <h2>Access matrix</h2>
        <button class="secondary" id="refreshAccessSummaryBtn">Refresh</button>
        <div class="status" id="accessSummaryStatus">Not loaded</div>
        <div class="table-wrap">
          <table id="accessSummaryTable">
            <thead><tr><th>User</th><th>Role</th><th>Folders</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="card">
        <h2>Job types</h2>
        <div class="grid">
          <div><label>Customer</label><input id="jobCustomer" type="text"></div>
          <div><label>Job Name</label><input id="jobName" type="text"></div>
          <div><label>Job Type</label><input id="jobType" type="text"></div>
          <div><label>Priority</label><input id="jobPriority" type="number" value="0"></div>
          <div><label>Folder prefix</label><input id="jobFolderPrefix" type="text" placeholder="e.g. NZME_EXP_AUD"></div>
          <div><label>Active verifiers</label><input id="jobVerifiers" type="number" value="0"></div>
        </div>
        <button id="createJobBtn">Create job</button>
        <div class="status" id="jobsAdminStatus"></div>
      </div>

      <div class="card">
        <h2>Job configuration (JSON)</h2>
        <div class="grid">
          <div><label>Job prefix</label><input id="jobConfigPrefix" type="text" placeholder="e.g. JAR"></div>
        </div>
        <label>Config JSON</label>
        <textarea id="jobConfigJson" placeholder='{"required_fields":["Invoice Number","Invoice Date"],"export_schema":[{"column":"Invoice No","field":"Invoice Number"}]}'></textarea>
        <div class="row" style="gap:8px;">
          <button class="secondary" id="jobConfigLoadBtn">Load</button>
          <button id="jobConfigSaveBtn">Save</button>
        </div>
        <div class="status" id="jobConfigStatus">Not loaded</div>
      </div>

      <div class="card">
        <h2>Reporting</h2>
        <div class="grid">
          <div><label>Month</label><input id="reportMonth" type="month"></div>
          <div><label>Job prefix (optional)</label><input id="reportJobPrefix" type="text" placeholder="e.g. JAR"></div>
        </div>
        <button class="secondary" id="runReportBtn">Run report</button>
        <button class="secondary" id="downloadReportCsvBtn">Download CSV</button>
        <div class="status" id="reportStatus">Not run</div>
        <div class="table-wrap">
          <table id="reportTable">
            <thead><tr><th>Job</th><th>Documents</th><th>Pages</th><th>To Review</th><th>Approved</th><th>Rejection Status</th><th>Hold</th><th>Exported</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="card">
        <h2>Billing</h2>
        <div class="grid">
          <div><label>Month</label><input id="billingMonth" type="month"></div>
          <div><label>Job prefix (optional)</label><input id="billingJobPrefix" type="text" placeholder="e.g. JAR"></div>
        </div>
        <button class="secondary" id="runBillingBtn">Run billing</button>
        <button class="secondary" id="downloadBillingCsvBtn">Download Billing CSV</button>
        <div class="status" id="billingStatus">Not run</div>
        <div class="table-wrap">
          <table id="billingTable">
            <thead><tr><th>Customer</th><th>Job Type</th><th>Jobs</th><th>Documents</th><th>Pages</th><th>To Review</th><th>Approved</th><th>Rejection Status</th><th>Hold</th><th>Exported</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="card">
        <h2>Automation</h2>
        <div class="row" style="align-items:flex-end;">
          <div style="min-width:260px;">
            <label>Global automation</label>
            <select id="automationEnabled" class="compact-select">
              <option value="true">Enabled</option>
              <option value="false">Disabled</option>
            </select>
          </div>
          <button class="secondary" id="automationRefreshBtn">Refresh</button>
          <button id="automationSaveBtn">Save</button>
          <div class="status" id="automationStatus" style="flex:1 1 320px; margin:0;">Unknown</div>
        </div>
      </div>

      <div class="card">
        <h2>Reference data (CSV)</h2>
        <div class="grid">
          <div>
            <label>Upload CSV</label>
            <input id="refUploadInput" type="file" accept=".csv">
          </div>
        </div>
        <button id="refUploadBtn">Upload</button>
        <button class="secondary" id="refReloadBtn">Reload from disk</button>
        <button class="secondary" id="refImportFtpBtn">Import from FTP</button>
        <div class="status" id="refStatus">Not loaded</div>
      </div>
    </section>
  </main>

  <script>
	    const state = {
	      token: localStorage.getItem('token') || '',
	      role: localStorage.getItem('role') || '',
	      email: localStorage.getItem('email') || '',
	      jobs: [],
	      users: [],
	      jobConfig: {},
	      reportData: null,
	      billingData: null,
	      fieldMeta: {},
	      validationErrors: [],
	      current: { folder: '', filename: '', key: '' },
	      polling: null,
	      selectedJob: null,
	      documents: [],
      docCursor: null,
      selectedDoc: null,
      layout: localStorage.getItem('docLayout') || 'row-lr',
      groupMode: localStorage.getItem('docGroupMode') || 'none',
      groupDate: localStorage.getItem('docGroupDate') || '',
    };

    const views = ['login','jobs','admin'];
    const viewElems = Object.fromEntries(views.map(v => [v, document.getElementById('view-'+v)]));
    const navButtons = document.querySelectorAll('header button[data-view]');
    const navContainer = document.getElementById('navButtons');
    const adminBtn = document.querySelector('header button[data-view="admin"]');
    const userInfo = document.getElementById('userInfo');

    const loginEmail = document.getElementById('loginEmail');
    const loginPass = document.getElementById('loginPass');
    const loginBtn = document.getElementById('loginBtn');
    const loginStatus = document.getElementById('loginStatus');

    const jobsStatus = document.getElementById('jobsStatus');
    const jobsTableBody = document.querySelector('#jobsTable tbody');
    const selectedJobBox = document.getElementById('selectedJob');
    const jobContext = document.getElementById('jobContext');
    const uploadCard = document.getElementById('uploadCard');
    const uploadBody = document.getElementById('uploadBody');
    const fileInput = document.getElementById('fileInput');
    const uploadBtn = document.getElementById('uploadBtn');
    const statusBox = document.getElementById('statusBox');
    const textractCard = document.getElementById('textractCard');
    const textractStatus = document.getElementById('textractStatus');
    const textractData = document.getElementById('textractData');
    const rawJson = document.getElementById('rawJson');
    const exportLink = document.getElementById('exportLink');
    const jobFolderInput = document.getElementById('jobFolder');
    const docsJobLabel = document.getElementById('docsJobLabel');
    const refUploadInput = document.getElementById('refUploadInput');
    const refUploadBtn = document.getElementById('refUploadBtn');
    const refReloadBtn = document.getElementById('refReloadBtn');
    const refImportFtpBtn = document.getElementById('refImportFtpBtn');
    const refStatus = document.getElementById('refStatus');
    const docsCard = document.createElement('div');
    docsCard.className = 'card hidden collapsible';
    docsCard.dataset.collapsible = 'docs';
    docsCard.innerHTML = `
      <div class="collapsible-head">
        <h3>Documents in job <span id="docsJobLabel" style="font-weight:600;color:var(--muted);font-size:14px;"></span></h3>
        <button class="secondary" data-toggle="docs">Collapse</button>
      </div>
      <div class="collapsible-body" id="docsBody">
      <div class="row">
        <div>
          <label>Status filter</label>
          <select id="docStatusFilter" class="compact-select">
            <option value="To Review" selected>To Review</option>
            <option value="">All</option>
            <option value="Approved">Approved</option>
            <option value="Rejected">Rejection Status</option>
            <option value="Hold">Hold</option>
            <option value="Exported">Exported</option>
          </select>
        </div>
        <div>
          <label>Group by</label>
          <select id="docGroupBy" class="compact-select">
            <option value="none">None</option>
            <option value="day">Day</option>
            <option value="month">Month</option>
          </select>
        </div>
        <div id="groupPeriodControls" class="hidden" style="display:flex; gap:6px; align-items:flex-end;">
          <div>
            <label>Period start</label>
            <input type="date" id="groupDateInput" style="min-width:160px;">
          </div>
          <div class="row" style="gap:6px;">
            <button class="secondary" id="groupPrev">←</button>
            <button class="secondary" id="groupNext">→</button>
          </div>
        </div>
	        <button id="refreshDocsBtn" class="secondary">Refresh</button>
	        <button id="exportApprovedBtn" class="secondary">Export Approved</button>
	        <button id="exportRejectedBtn" class="secondary">Export Rejected</button>
	        <button id="exportHoldBtn" class="secondary">Export Hold</button>
	      </div>
      <div class="table-wrap">
        <table id="docsTable">
          <thead><tr>
            <th>Status</th><th>Name</th><th>Created</th><th>Invoice #</th><th>Invoice Date</th><th>Total</th><th>Supplier</th>
          </tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="status" id="docsStatus">No data</div>
      </div>
    `;
    const docsContainer = document.getElementById('docsContainer');
    docsContainer.appendChild(docsCard);

    const docDetailCard = document.createElement('div');
	    docDetailCard.className = 'card hidden';
	    docDetailCard.innerHTML = `
	      <h3>Document</h3>
	      <div id="docInfo"></div>
	      <div class="row" style="gap:8px; align-items:center; flex-wrap:wrap; margin:10px 0;">
	        <button id="docGenerateExportBtn" class="secondary">Export to S3</button>
	        <div id="docExportStatus" class="status" style="margin:0; flex:1 1 320px;">Export not generated</div>
	      </div>
	      <div class="row" style="gap:8px; align-items:center; flex-wrap:wrap;">
	        <button class="secondary" data-layout="row-lr">Doc left</button>
	        <button class="secondary" data-layout="row-rl">Doc right</button>
	        <button class="secondary" data-layout="col-tb">Doc top</button>
        <button class="secondary" data-layout="col-bt">Doc bottom</button>
        <div class="zoom-controls">
          <button id="zoomIn" class="secondary">+</button>
          <button id="zoomOut" class="secondary">-</button>
        </div>
      </div>
      <div id="docLayoutWrap" class="doc-layout">
        <div id="pdfContainer" class="doc-pdf" style="position:relative; border:1px solid var(--border); border-radius:8px; overflow:auto; min-height:400px; background:#0b1623;">
          <canvas id="pdfCanvas" style="width:100%; display:block;"></canvas>
          <div id="pdfOverlay" style="position:absolute; inset:0; pointer-events:none;"></div>
	        </div>
	        <div class="doc-fields">
      <div class="row" style="align-items:flex-end;">
        <button id="docLookupBtn" class="secondary">Lookup & Autofill</button>
        <div id="docLookupStatus" class="status" style="flex:1 1 320px; margin:0;">Lookup not run</div>
      </div>
	      <div class="row" style="align-items:flex-end;">
	        <div>
	          <label>Customer ID lookup</label>
	          <input id="customerLookupInput" class="compact-select" placeholder="Enter customer ID">
	        </div>
        <button id="customerLookupBtn">Lookup</button>
        <div id="customerLookupStatus" class="status" style="min-width:220px;">Lookup not started</div>
      </div>
	          <div class="legend">
	            <strong>Confidence legend:</strong>
	            <span><span class="dot green"></span>80%+</span>
	            <span><span class="dot amber"></span>70–79%</span>
	            <span><span class="dot red"></span><70%</span>
	          </div>
	          <div class="grid" id="docFields"></div>
	          <div id="docValidationStatus" class="status" style="margin-top:12px;">Validation not checked</div>
	        </div>
	      </div>
	      <div class="row" style="align-items:flex-end;">
	        <div>
          <label style="width:120px;">Status</label>
          <select id="docStatusSelect" class="compact-select">
            <option value="To Review">To Review</option>
            <option value="Approved">Approved</option>
            <option value="Rejected">Rejection Status</option>
            <option value="Hold">Hold</option>
            <option value="Exported">Exported</option>
          </select>
        </div>
        <div id="docReasonWrap" class="hidden">
          <label>Rejection reason</label>
          <select id="docReasonSelect" class="compact-select">
            <option value="">Select reason</option>
            <option value="Not valid">Not valid</option>
            <option value="Illegible">Illegible</option>
            <option value="Missing date/number">Missing date/number</option>
            <option value="Unknown supplier">Unknown supplier</option>
            <option value="Duplicate">Duplicate</option>
            <option value="Wrong job">Wrong job</option>
            <option value="Not an invoice">Not an invoice</option>
            <option value="Missing PO">Missing PO</option>
            <option value="Other">Other</option>
          </select>
        </div>
        <button id="docSaveBtn">Save</button>
      </div>
	    `;
	    docsContainer.appendChild(docDetailCard);

				    const docExportStatus = docDetailCard.querySelector('#docExportStatus');
				    const docGenerateExportBtn = docDetailCard.querySelector('#docGenerateExportBtn');
				    const docReasonWrap = docDetailCard.querySelector('#docReasonWrap');
				    const docReasonSelect = docDetailCard.querySelector('#docReasonSelect');
				    const docValidationStatus = docDetailCard.querySelector('#docValidationStatus');
				    const docLookupBtn = docDetailCard.querySelector('#docLookupBtn');
				    const docLookupStatus = docDetailCard.querySelector('#docLookupStatus');
			    const customerLookupInput = document.getElementById('customerLookupInput');
			    const customerLookupBtn = document.getElementById('customerLookupBtn');
			    const customerLookupStatus = document.getElementById('customerLookupStatus');

		    if (docGenerateExportBtn) {
		      docGenerateExportBtn.addEventListener('click', async () => {
		        if (!state.selectedDoc) return;
		        try {
		          docGenerateExportBtn.disabled = true;
		          if (docExportStatus) docExportStatus.textContent = 'Generating export…';
	          const res = await api('/api/export/generate', {
	            method: 'POST',
	            body: JSON.stringify({ key: state.selectedDoc.key, upload_ftp: false })
	          });
	          if (state.selectedDoc && state.selectedDoc.payload) {
	            state.selectedDoc.payload.status = 'Exported';
	          }
	          const statusSel = docDetailCard.querySelector('#docStatusSelect');
	          if (statusSel) statusSel.value = 'Exported';
	          await refreshDocs(true);
	          await lookupDocExport();
	          if (res && res.url && docExportStatus) {
	            docExportStatus.innerHTML = `<span class="pill green">Ready</span> <a href="${res.url}" target="_blank">Download ZIP</a> <span style="color:var(--muted);">${res.export_key || ''}</span>`;
	          }
	        } catch (e) {
	          if (docExportStatus) docExportStatus.textContent = 'Export error: ' + e.message;
	        } finally {
	          if (docGenerateExportBtn) {
	            const statusSel = docDetailCard.querySelector('#docStatusSelect');
	            const s = statusSel ? (statusSel.value || '') : '';
	            docGenerateExportBtn.disabled = (s === 'To Review' || s === 'Hold' || s === 'Exported');
	          }
	        }
		      });
		    }

		    if (docLookupBtn) {
		      docLookupBtn.addEventListener('click', async () => {
		        if (!state.selectedDoc) return;
		        try {
		          docLookupBtn.disabled = true;
		          if (docLookupStatus) docLookupStatus.textContent = 'Running lookup...';
		          const fields = collectDocEdits();
		          const res = await api('/api/documents/lookup', {
		            method: 'POST',
		            body: JSON.stringify({ key: state.selectedDoc.key, fields })
		          });
		          const inputs = docDetailCard.querySelectorAll('input[data-field]');
		          const suggestions = (res && Array.isArray(res.suggested_fields)) ? res.suggested_fields : [];
		          let applied = 0;
		          function tryApply(inp, value) {
		            const meta = getFieldMeta(inp.dataset.field || '');
		            if (meta.locked) return;
		            if ((inp.value || '').trim()) return;
		            inp.value = value;
		            meta.autofilled = true;
		            applied += 1;
		          }
		          suggestions.forEach(s => {
		            const field = String(s.field || '').trim();
		            const value = String(s.value || '').trim();
		            if (!field || !value) return;
		            const exact = Array.from(inputs).find(inp => lowerKey(inp.dataset.field) === lowerKey(field));
		            if (exact) { tryApply(exact, value); return; }
		            const fk = lowerKey(field);
		            if (fk.includes('supplier') || fk.includes('vendor') || fk.includes('creditor')) {
		              inputs.forEach(inp => {
		                const k = lowerKey(inp.dataset.field);
		                if (k.includes('supplier') || k.includes('vendor') || k.includes('creditor')) tryApply(inp, value);
		              });
		            } else if (fk.includes('gst') || fk.includes('abn')) {
		              inputs.forEach(inp => {
		                const k = lowerKey(inp.dataset.field);
		                if (k.includes('gst') || k.includes('abn')) tryApply(inp, value);
		              });
		            }
		          });
		          if (applied) scheduleValidate();
		          const sup = (res && res.supplier) ? res.supplier : {};
		          const po = (res && res.po) ? res.po : {};
		          const inv = (res && res.invoice) ? res.invoice : {};
		          const supName = (sup && sup.selected && sup.selected.data) ? (sup.selected.data.name || sup.selected.data.customer_id || '') : '';
		          const poNo = (po && po.selected && po.selected.data) ? (po.selected.data.po_number || '') : '';
		          const invNo = (inv && inv.selected && inv.selected.data) ? (inv.selected.data.invoice_number || '') : '';
		          if (docLookupStatus) {
		            docLookupStatus.textContent = `Supplier: ${sup.status || 'n/a'}${supName ? ' (' + supName + ')' : ''} | PO: ${po.status || 'n/a'}${poNo ? ' (' + poNo + ')' : ''} | Invoice: ${inv.status || 'n/a'}${invNo ? ' (' + invNo + ')' : ''} | Applied: ${applied}`;
		          }
		        } catch (e) {
		          if (docLookupStatus) docLookupStatus.textContent = 'Lookup error: ' + e.message;
		        } finally {
		          docLookupBtn.disabled = false;
		        }
		      });
		    }

		    const createUserBtn = document.getElementById('createUserBtn');
		    const usersStatus = document.getElementById('usersStatus');
		    const usersTableBody = document.querySelector('#usersTable tbody');
    const userEmail = document.getElementById('userEmail');
    const userPass = document.getElementById('userPass');
    const userRole = document.getElementById('userRole');
    const createAccessBtn = document.getElementById('createAccessBtn');
    const accessStatus = document.getElementById('accessStatus');
    const accessTableBody = document.querySelector('#accessTable tbody');
    const accessUserSelect = document.getElementById('accessUserSelect');
    const accessFoldersWrap = document.getElementById('accessFoldersWrap');

    const createJobBtn = document.getElementById('createJobBtn');
    const jobsAdminStatus = document.getElementById('jobsAdminStatus');
	    const jobCustomer = document.getElementById('jobCustomer');
	    const jobName = document.getElementById('jobName');
	    const jobType = document.getElementById('jobType');
	    const jobPriority = document.getElementById('jobPriority');
	    const jobFolderPrefix = document.getElementById('jobFolderPrefix');
	    const jobVerifiers = document.getElementById('jobVerifiers');
	    const jobConfigPrefix = document.getElementById('jobConfigPrefix');
	    const jobConfigJson = document.getElementById('jobConfigJson');
	    const jobConfigLoadBtn = document.getElementById('jobConfigLoadBtn');
	    const jobConfigSaveBtn = document.getElementById('jobConfigSaveBtn');
	    const jobConfigStatus = document.getElementById('jobConfigStatus');
	    const reportMonth = document.getElementById('reportMonth');
		    const reportJobPrefix = document.getElementById('reportJobPrefix');
		    const runReportBtn = document.getElementById('runReportBtn');
		    const downloadReportCsvBtn = document.getElementById('downloadReportCsvBtn');
		    const reportStatus = document.getElementById('reportStatus');
		    const reportTableBody = document.querySelector('#reportTable tbody');
		    const billingMonth = document.getElementById('billingMonth');
		    const billingJobPrefix = document.getElementById('billingJobPrefix');
		    const runBillingBtn = document.getElementById('runBillingBtn');
		    const downloadBillingCsvBtn = document.getElementById('downloadBillingCsvBtn');
		    const billingStatus = document.getElementById('billingStatus');
		    const billingTableBody = document.querySelector('#billingTable tbody');
		    const automationEnabled = document.getElementById('automationEnabled');
		    const automationRefreshBtn = document.getElementById('automationRefreshBtn');
		    const automationSaveBtn = document.getElementById('automationSaveBtn');
		    const automationStatus = document.getElementById('automationStatus');
	    const pdfRenderState = {
	      url: null,
	      norm: [],
	      scale: 1,
      focusBox: null,
      pageViewport: null,
      highlightBox: null,
      pdf: null,
      page: null,
      baseViewport: null,
      loadingTask: null,
      renderTask: null,
      renderId: 0,
    };
    const themeToggle = document.getElementById('themeToggle');
    const layoutButtons = document.querySelectorAll('[data-layout]');

    if (window.pdfjsLib) {
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = "/static/pdf.worker.min.js";
    }

    function showView(name) {
      views.forEach(v => viewElems[v].classList.add('hidden'));
      viewElems[name].classList.remove('hidden');
    }

    function setUserInfo() {
      if (state.token) {
	        userInfo.innerHTML = `<span class="pill green">${state.role}</span> ${state.email} <button class="secondary" onclick="logout()">Logout</button>`;
	        navContainer.classList.remove('hidden');
	        if (adminBtn) adminBtn.style.display = state.role === 'admin' ? '' : 'none';
	        const exportBtns = [document.getElementById('exportApprovedBtn'), document.getElementById('exportRejectedBtn'), document.getElementById('exportHoldBtn')];
	        exportBtns.forEach(btn => { if (btn) btn.style.display = state.role === 'admin' ? '' : 'none'; });
	      } else {
	        userInfo.textContent = 'Not authenticated';
	        navContainer.classList.add('hidden');
	        if (adminBtn) adminBtn.style.display = 'none';
	        const exportBtns = [document.getElementById('exportApprovedBtn'), document.getElementById('exportRejectedBtn'), document.getElementById('exportHoldBtn')];
	        exportBtns.forEach(btn => { if (btn) btn.style.display = 'none'; });
	      }
	    }
    function setTheme(theme) {
      const t = theme === 'light' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', t);
      localStorage.setItem('theme', t);
      if (themeToggle) {
        themeToggle.textContent = t === 'dark' ? 'Light mode' : 'Dark mode';
      }
    }
	    window.logout = function() {
	      if (presenceInterval) { clearInterval(presenceInterval); presenceInterval = null; }
	      state.token = ''; state.role=''; state.email=''; state.selectedJob = null;
	      if (jobContext) { jobContext.classList.add('hidden'); jobContext.textContent = ''; }
	      if (docsJobLabel) { docsJobLabel.textContent = ''; }
	      localStorage.removeItem('token'); localStorage.removeItem('role'); localStorage.removeItem('email');
	      setUserInfo(); showView('login');
	    }

	    navButtons.forEach(btn => btn.addEventListener('click', () => {
	      const v = btn.dataset.view;
	      if (v === 'admin' && state.role !== 'admin') return alert('Admin only');
	      showView(v);
	      if (v === 'jobs') refreshJobs();
	      if (v === 'admin') { refreshUsers(); refreshAccess(); refreshJobs(); refreshAccessSummary(); refreshAutomation(); }
	    }));
    if (themeToggle) {
      themeToggle.addEventListener('click', () => {
        const current = localStorage.getItem('theme') || 'dark';
        setTheme(current === 'dark' ? 'light' : 'dark');
      });
    }

    function colorPill(conf) {
      if (conf >= 0.8) return 'green';
      if (conf >= 0.7) return 'amber';
      return 'red';
    }

    function confidenceColor(conf) {
      if (conf >= 0.8) return '#22c55e';
      if (conf >= 0.7) return '#fbbf24';
      return '#ef4444';
    }

    function normalizeConfidence(val) {
      const num = parseFloat(val);
      return Number.isFinite(num) ? num : 0;
    }

    function isValidBox(box) {
      if (!box) return false;
      const left = Number(box.Left);
      const top = Number(box.Top);
      const width = Number(box.Width);
      const height = Number(box.Height);
      if (![left, top, width, height].every(v => Number.isFinite(v))) return false;
      if (width <= 0 || height <= 0) return false;
      if (left < 0 || top < 0) return false;
      if (left > 1.05 || top > 1.05) return false;
      if (left + width < 0 || top + height < 0) return false;
      if (left + width > 1.1 || top + height > 1.1) return false;
      return true;
    }

	    async function api(path, options = {}) {
	      const headers = options.headers || {};
	      headers['Content-Type'] = options.body ? 'application/json' : headers['Content-Type'];
	      if (state.token) headers['Authorization'] = 'Bearer ' + state.token;
	      const resp = await fetch(path, { ...options, headers });
	      const text = await resp.text();
	      let data = null;
	      if (text) {
	        try { data = JSON.parse(text); } catch (_) { data = null; }
	      }
		      if (!resp.ok) {
		        const detail = data && (data.detail ?? data.error ?? data.message);
		        let msg = text || resp.statusText || 'Request failed';
		        if (typeof detail === 'string') {
		          msg = detail;
		        } else if (detail && typeof detail === 'object') {
		          msg = detail.message || msg;
		          if (Array.isArray(detail.errors) && detail.errors.length) {
		            const parts = detail.errors.slice(0, 6).map(e => `${e.field || 'field'}: ${e.error || 'invalid'}`);
		            msg += ` (${parts.join(', ')}${detail.errors.length > 6 ? '…' : ''})`;
		          }
		        }
		        const err = new Error(msg);
		        err.status = resp.status;
		        err.data = data;
		        err.raw = text;
		        throw err;
		      }
	      return data ?? {};
	    }

	    let presenceInterval = null;
	    async function pingPresence() {
	      if (!state.token || !state.selectedJob) return;
	      try {
	        await api('/api/presence', { method: 'POST', body: JSON.stringify({ folder_prefix: state.selectedJob.folder_prefix }) });
	      } catch (_) {
	        // ignore presence failures
	      }
	    }
	    function startPresence(jobPrefix) {
	      if (presenceInterval) { clearInterval(presenceInterval); presenceInterval = null; }
	      if (!jobPrefix) return;
	      pingPresence();
	      presenceInterval = setInterval(pingPresence, 30000);
	    }

	    loginBtn.addEventListener('click', async () => {
	      try {
	        loginBtn.disabled = true;
	        loginStatus.textContent = 'Signing in...';
        const data = await api('/auth/login', { method: 'POST', body: JSON.stringify({ email: loginEmail.value, password: loginPass.value }) });
        state.token = data.token; state.role = data.role; state.email = data.email;
        localStorage.setItem('token', state.token);
        localStorage.setItem('role', state.role);
        localStorage.setItem('email', state.email);
        loginStatus.textContent = 'Success';
        setUserInfo();
        showView('jobs');
        refreshJobs();
      } catch (e) {
        loginStatus.textContent = 'Error: ' + e.message;
      } finally {
        loginBtn.disabled = false;
      }
    });

    async function refreshJobs() {
      if (!state.token) { jobsStatus.textContent = 'Login required'; return; }
      jobsStatus.textContent = 'Loading...';
      try {
        const jobs = await api('/jobs');
        state.jobs = jobs;
        jobsTableBody.innerHTML = '';
	        for (const j of jobs) {
	          const tr = document.createElement('tr');
	          const active = Array.isArray(j.active_verifiers) ? j.active_verifiers : [];
	          const assigned = Array.isArray(j.assigned_verifiers) ? j.assigned_verifiers : [];
	          const activeText = active.join(', ');
	          const verifiersHtml = `${activeText || '-'}${assigned.length ? ` <span style="color:var(--muted);">(${assigned.length} assigned)</span>` : ''}`;
	          tr.innerHTML = `<td>${j.customer}</td><td>${j.name}</td><td>${j.job_type}</td><td>${j.documents_to_review ?? '-'}</td><td>${j.priority}</td><td>${j.folder_prefix}</td><td>${verifiersHtml}</td>`;
	          tr.addEventListener('click', () => selectJob(j));
	          jobsTableBody.appendChild(tr);
	        }
        jobsStatus.textContent = `${jobs.length} results`;
      } catch (e) {
        jobsStatus.textContent = 'Error: ' + e.message;
      }
    }

    async function loadJobConfig(jobPrefix) {
      state.jobConfig = {};
      if (!jobPrefix) return;
      try {
        const data = await api('/api/job-config?job=' + encodeURIComponent(jobPrefix), { method: 'GET' });
        state.jobConfig = (data && data.config && typeof data.config === 'object') ? data.config : {};
      } catch (_) {
        state.jobConfig = {};
      }
    }

    async function selectJob(job) {
      state.selectedJob = job;
      selectedJobBox.textContent = `Selected: ${job.customer} / ${job.name} (${job.folder_prefix})`;
      if (jobContext) {
        jobContext.textContent = `${job.customer} / ${job.name} (${job.folder_prefix})`;
        jobContext.classList.remove('hidden');
      }
	      if (docsJobLabel) {
	        docsJobLabel.textContent = ` — ${job.customer} / ${job.name} (${job.folder_prefix})`;
	      }
	      jobFolderInput.value = job.folder_prefix;
	      if (jobConfigPrefix) jobConfigPrefix.value = job.folder_prefix;
	      uploadCard.classList.remove('hidden');
	      docsCard.classList.remove('hidden');
	      docDetailCard.classList.add('hidden');
	      setCollapsed('jobsList', true);
	      setCollapsed('upload', false);
	      setCollapsed('docs', false);
	      await loadJobConfig(job.folder_prefix);
	      startPresence(job.folder_prefix);
	      refreshDocs(true);
	    }

    async function refreshDocs(reset=false) {
      if (!state.selectedJob) return;
      if (reset) { state.docCursor = null; state.documents = []; }
      const filter = document.getElementById('docStatusFilter').value;
      docsStatus.textContent = 'Loading...';
      try {
        const qs = new URLSearchParams({ job: state.selectedJob.folder_prefix, page_size: 50 });
        if (filter) qs.append('status', filter);
        if (state.docCursor) qs.append('cursor', state.docCursor);
        const data = await api('/api/documents?' + qs.toString());
        state.documents = reset ? data.items : state.documents.concat(data.items || []);
        state.docCursor = data.next_cursor || null;
        renderDocs();
        docsStatus.textContent = `${state.documents.length} records${data.truncated ? ' (more available)' : ''}`;
      } catch (e) {
        docsStatus.textContent = 'Error: ' + e.message;
      }
    }

    function findNextToReview(currentKey) {
      const docs = state.documents || [];
      const start = docs.findIndex(d => d.key === currentKey);
      for (let i = (start >= 0 ? start + 1 : 0); i < docs.length; i++) {
        if ((docs[i].status || '') === 'To Review') return docs[i];
      }
      for (const d of docs) {
        if ((d.status || '') === 'To Review') return d;
      }
      return null;
    }

    function renderDocs() {
      const tbody = docsCard.querySelector('#docsTable tbody');
      tbody.innerHTML = '';
      const groupMode = state.groupMode || 'none';
      const statusFilter = document.getElementById('docStatusFilter').value || '';
      const statusFilterLower = statusFilter.toLowerCase();
      // optional period filter when grouping
      const periodStart = state.groupDate;
      const parseDate = (val) => {
        if (!val) return null;
        const d = new Date(val);
        return isNaN(d.getTime()) ? null : d;
      };
      const periodDate = parseDate(periodStart);
      const sameDay = (d) => {
        if (!periodDate || !d) return true;
        return d.getUTCFullYear() === periodDate.getUTCFullYear() &&
               d.getUTCMonth() === periodDate.getUTCMonth() &&
               d.getUTCDate() === periodDate.getUTCDate();
      };
      const sameMonth = (d) => {
        if (!periodDate || !d) return true;
        return d.getUTCFullYear() === periodDate.getUTCFullYear() &&
               d.getUTCMonth() === periodDate.getUTCMonth();
      };

      const filteredDocs = state.documents.filter(d => {
        if (statusFilter) {
          const s = (d.status || '').toLowerCase();
          if (statusFilterLower === 'to review') {
            if (!(s === '' || s === 'to review')) return false;
          } else if (s !== statusFilterLower) {
            return false;
          }
        }
        if (groupMode === 'none') return true;
        const dt = parseDate(d.created_at);
        if (!dt) return false;
        if (groupMode === 'day') return sameDay(dt);
        if (groupMode === 'month') return sameMonth(dt);
        return true;
      });

      if (groupMode === 'none') {
        for (const d of filteredDocs) {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${d.status || ''}</td><td>${d.name || ''}</td><td>${d.created_at || ''}</td><td>${d.invoice_number || ''}</td><td>${d.invoice_date || ''}</td><td>${d.total_amount || ''}</td><td>${d.supplier || ''}</td>`;
          tr.addEventListener('click', () => openDoc(d));
          tbody.appendChild(tr);
        }
      } else {
        const groups = {};
        const fmtDay = (dstr) => (dstr || '').slice(0, 10) || 'Unknown';
        const fmtMonth = (dstr) => {
          if (!dstr) return 'Unknown';
          const d = parseDate(dstr);
          if (!d) return 'Unknown';
          return `${d.getUTCFullYear()}-${String(d.getUTCMonth() + 1).padStart(2,'0')}`;
        };
        const labelFn = groupMode === 'day' ? fmtDay : fmtMonth;
        for (const d of filteredDocs) {
          const label = labelFn(d.created_at);
          groups[label] = groups[label] || [];
          groups[label].push(d);
        }
        Object.entries(groups).forEach(([label, rows]) => {
          const hr = document.createElement('tr');
          const hd = document.createElement('td');
          hd.colSpan = 7;
          hd.style.fontWeight = '700';
          hd.textContent = label || 'Unknown';
          hr.appendChild(hd);
          tbody.appendChild(hr);
          rows.forEach(d => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${d.status || ''}</td><td>${d.name || ''}</td><td>${d.created_at || ''}</td><td>${d.invoice_number || ''}</td><td>${d.invoice_date || ''}</td><td>${d.total_amount || ''}</td><td>${d.supplier || ''}</td>`;
            tr.addEventListener('click', () => openDoc(d));
            tbody.appendChild(tr);
          });
        });
      }
      if (state.docCursor) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 7;
        const btn = document.createElement('button');
        btn.textContent = 'Load more';
        btn.addEventListener('click', () => refreshDocs(false));
        td.appendChild(btn);
        tr.appendChild(td);
        tbody.appendChild(tr);
      }
    }

    async function openDoc(doc) {
      try {
        const data = await api('/api/documents/detail?key=' + encodeURIComponent(doc.key));
        state.selectedDoc = { ...doc, payload: data.payload, pdf_url: data.pdf_url, source_bucket: data.source_bucket, source_file: data.source_key };
        renderDocDetail();
        // Collapse documents list when a document is open to focus on the detail view.
        setCollapsed('docs', true);
      } catch (e) {
        alert('Failed to open document: ' + e.message);
      }
    }

    function renderAccessUserOptions(users) {
      if (!accessUserSelect) return;
      accessUserSelect.innerHTML = '<option value="">Select user</option>';
      users.forEach(u => {
        const opt = document.createElement('option');
        opt.value = u.id;
        opt.textContent = `${u.email} (${u.role})`;
        accessUserSelect.appendChild(opt);
      });
      accessUserSelect.addEventListener('change', renderAccessFolders);
    }

    function renderAccessFolders() {
      if (!accessFoldersWrap) return;
      const userId = parseInt(accessUserSelect.value || '0', 10);
      accessFoldersWrap.innerHTML = '';
      const allowed = (state.userAccess || []).filter(a => a.user_id === userId).map(a => a.folder_prefix);
      const folders = state.jobs.map(j => j.folder_prefix);
      const unique = Array.from(new Set(folders));
      unique.forEach(folder => {
        const id = `folder-${folder}`;
        const wrap = document.createElement('label');
        wrap.style.display = 'flex';
        wrap.style.alignItems = 'center';
        wrap.style.gap = '6px';
        wrap.innerHTML = `<input type="checkbox" id="${id}" value="${folder}" ${allowed.includes(folder) ? 'checked' : ''}> ${folder}`;
        accessFoldersWrap.appendChild(wrap);
      });
    }

    function setCollapsed(name, collapsed) {
      const target = document.querySelector(`[data-collapsible="${name}"] .collapsible-body`) || document.querySelector(`[data-collapsible="${name}"]`);
      const toggleBtn = document.querySelector(`[data-toggle="${name}"]`);
      if (target) {
        if (collapsed) target.classList.add('collapsed'); else target.classList.remove('collapsed');
      }
      if (toggleBtn) {
        toggleBtn.textContent = collapsed ? 'Expand' : 'Collapse';
      }
    }

	    function setLayout(mode) {
	      const wrap = document.getElementById('docLayoutWrap');
	      if (!wrap) return;
      const valid = ['row-lr','row-rl','col-tb','col-bt'];
      const m = valid.includes(mode) ? mode : 'row-lr';
      wrap.classList.remove('layout-row-lr','layout-row-rl','layout-col-tb','layout-col-bt');
      wrap.classList.add(`layout-${m}`);
      state.layout = m;
      localStorage.setItem('docLayout', m);
	      layoutButtons.forEach(btn => {
	        btn.classList.toggle('secondary', btn.getAttribute('data-layout') !== m);
	        btn.classList.toggle('pill', btn.getAttribute('data-layout') === m);
	      });
	    }

	    function lowerKey(s) {
	      return String(s || '').trim().toLowerCase();
	    }

	    function collectDocEdits() {
	      const inputs = docDetailCard.querySelectorAll('input[data-field]');
	      return Array.from(inputs).map(i => ({ field_name: i.dataset.field, value: i.value }));
	    }

	    function getFieldMeta(fieldKey) {
	      const k = lowerKey(fieldKey);
	      if (!state.fieldMeta[k]) state.fieldMeta[k] = { locked: false, autofilled: false };
	      return state.fieldMeta[k];
	    }

	    function clearValidationUI() {
	      state.validationErrors = [];
	      const wraps = docDetailCard.querySelectorAll('.field-error');
	      wraps.forEach(w => { w.textContent = ''; });
	      const inputs = docDetailCard.querySelectorAll('input[data-field]');
	      inputs.forEach(inp => {
	        inp.classList.remove('has-validation-error');
	        const baseBorder = inp.dataset.baseBorder;
	        const baseShadow = inp.dataset.baseShadow;
	        if (baseBorder) inp.style.border = `2px solid ${baseBorder}`;
	        if (baseShadow) inp.style.boxShadow = baseShadow;
	      });
	      if (docValidationStatus) docValidationStatus.textContent = 'Validation not checked';
	    }

	    function renderValidationErrors(errors) {
	      state.validationErrors = Array.isArray(errors) ? errors : [];
	      const byField = {};
	      state.validationErrors.forEach(e => {
	        const k = lowerKey(e.field);
	        if (!k) return;
	        byField[k] = e;
	      });
	      const inputs = docDetailCard.querySelectorAll('input[data-field]');
	      inputs.forEach(inp => {
	        const wrap = inp.closest('div');
	        const errEl = wrap ? wrap.querySelector('.field-error') : null;
	        if (errEl) errEl.textContent = '';
	        const baseBorder = inp.dataset.baseBorder;
	        const baseShadow = inp.dataset.baseShadow;
	        if (baseBorder) inp.style.border = `2px solid ${baseBorder}`;
	        if (baseShadow) inp.style.boxShadow = baseShadow;

	        const k = lowerKey(inp.dataset.field);
	        const err = byField[k];
	        const msg = err ? (err.error === 'required' ? 'Required' : err.error === 'invalid_date' ? 'Invalid date' : err.error === 'invalid_amount' ? 'Invalid amount' : String(err.error || 'Invalid')) : '';
	        if (errEl) errEl.textContent = msg;
	        if (err) {
	          inp.style.border = '2px solid var(--danger)';
	          inp.style.boxShadow = '0 0 0 2px rgba(239,68,68,0.25)';
	        }
	      });
	      if (docValidationStatus) {
	        if (!state.validationErrors.length) {
	          docValidationStatus.innerHTML = `<span class="pill green">OK</span> No validation errors`;
	        } else {
	          docValidationStatus.innerHTML = `<span class="pill red">Errors</span> ${state.validationErrors.length} field(s) need attention`;
	        }
	      }
	    }

	    let _validateTimer = null;
	    async function validateSelectedDoc() {
	      if (!state.selectedDoc) return;
	      try {
	        const fields = collectDocEdits();
	        const res = await api('/api/documents/validate', { method: 'POST', body: JSON.stringify({ key: state.selectedDoc.key, fields }) });
	        renderValidationErrors(res && res.errors ? res.errors : []);
	      } catch (e) {
	        if (docValidationStatus) docValidationStatus.textContent = 'Validation error: ' + e.message;
	      }
	    }
	    function scheduleValidate() {
	      if (_validateTimer) clearTimeout(_validateTimer);
	      _validateTimer = setTimeout(validateSelectedDoc, 350);
	    }

	    async function autofillFromCustomerId() {
	      if (!state.selectedDoc) return;
	      const inputs = docDetailCard.querySelectorAll('input[data-field]');
	      const candidates = Array.from(inputs).filter(inp => {
	        const k = lowerKey(inp.dataset.field);
	        return k.includes('customer') || k.includes('creditor code') || k.includes('cre account') || k.includes('account code');
	      });
	      const cid = (candidates.length ? candidates[0].value : '').trim();
	      if (!cid) return;
	      try {
	        const qs = new URLSearchParams({ customer_id: cid });
	        const res = await api('/api/customers/lookup?' + qs.toString(), { method: 'GET' });
	        if (!res || res.status !== 'match' || !res.selected) return;
	        const match = res.selected;
	        let changed = false;
	        inputs.forEach(inp => {
	          const key = lowerKey(inp.dataset.field);
	          const meta = getFieldMeta(inp.dataset.field);
	          if (meta.locked) return;
	          if (!inp.value.trim()) {
	            if ((key.includes('supplier') || key.includes('creditor')) && match.name) {
	              inp.value = match.name;
	              meta.autofilled = true;
	              changed = true;
	            }
	            if ((key.includes('gst') || key.includes('abn')) && match.gst_abn) {
	              inp.value = match.gst_abn;
	              meta.autofilled = true;
	              changed = true;
	            }
	          }
	          if (key.includes('code') && match.customer_id && !inp.value.trim()) {
	            inp.value = match.customer_id;
	            meta.autofilled = true;
	            changed = true;
	          }
	        });
	        if (changed) scheduleValidate();
	      } catch (_) {
	        // ignore autofill failures
	      }
	    }

		    function renderDocDetail() {
		      if (!state.selectedDoc) return;
		      docDetailCard.classList.remove('hidden');
		      const info = docDetailCard.querySelector('#docInfo');
		      const statusSel = docDetailCard.querySelector('#docStatusSelect');
		      const fieldsWrap = docDetailCard.querySelector('#docFields');
		      const layoutWrap = document.getElementById('docLayoutWrap');
		      setLayout(state.layout);
		      state.fieldMeta = {};
		      clearValidationUI();

		      statusSel.value = state.selectedDoc.payload.status || 'To Review';
	      if (docGenerateExportBtn) {
	        const s = statusSel.value || 'To Review';
	        docGenerateExportBtn.disabled = (s === 'To Review' || s === 'Hold' || s === 'Exported');
	      }
	      if (docReasonSelect) {
	        docReasonSelect.value = state.selectedDoc.payload.reason || '';
	      }
	      const toggleReason = () => {
	        if (!docReasonWrap) return;
	        const show = statusSel.value === 'Rejected';
	        docReasonWrap.classList.toggle('hidden', !show);
	        if (!show && docReasonSelect) docReasonSelect.value = '';
	      };
	      statusSel.onchange = () => {
	        toggleReason();
	        if (docGenerateExportBtn) {
	          const s = statusSel.value || 'To Review';
	          docGenerateExportBtn.disabled = (s === 'To Review' || s === 'Hold' || s === 'Exported');
	        }
	        scheduleValidate();
	      };
	      toggleReason();
      const bucket = state.selectedDoc.source_bucket || (state.selectedDoc.payload && state.selectedDoc.payload.source_bucket) || '';
      const srcKey = state.selectedDoc.source_file || (state.selectedDoc.payload && state.selectedDoc.payload.source_file) || '';
      const tokenParam = state.token ? `&token=${encodeURIComponent(state.token)}` : '';
      const internalPdf = (bucket && srcKey) ? `/api/pdf?bucket=${encodeURIComponent(bucket)}&key=${encodeURIComponent(srcKey)}${tokenParam}` : null;
      const link = internalPdf ? `<a href="${internalPdf}" target="_blank">Open PDF</a>` : 'No PDF link';
      info.innerHTML = `<div class="status">File: ${state.selectedDoc.key} | ${link}</div>`;

      fieldsWrap.innerHTML = '';
      pdfRenderState.highlightBox = null;
      const cfg = state.jobConfig || {};
      const fieldOrder = Array.isArray(cfg.field_order) ? cfg.field_order : null;
      const fieldAliases = (cfg.field_aliases && typeof cfg.field_aliases === 'object') ? cfg.field_aliases : {};
      const requiredSet = new Set(Array.isArray(cfg.required_fields) ? cfg.required_fields.map(v => String(v || '').toLowerCase()) : []);

      const norm = state.selectedDoc.payload.normalized_data || [];
      const keyOf = (f) => String(f.key || f.field_name || '').trim();
      const lower = (s) => String(s || '').trim().toLowerCase();
      const byKey = {};
      norm.forEach(f => { const k = lower(keyOf(f)); if (k) byKey[k] = f; });
      const ordered = [];
      const used = new Set();
      if (fieldOrder) {
        fieldOrder.forEach(name => {
          const k = lower(name);
          if (!k) return;
          const found = byKey[k];
          if (found) ordered.push(found);
          else ordered.push({ key: String(name), value: '', confidence: 0 });
          used.add(k);
        });
      }
      norm.forEach(f => {
        const k = lower(keyOf(f));
        if (!k || used.has(k)) return;
        ordered.push(f);
      });
      // Build supplier suggestions from normalized data
      const supplierNames = new Set();
      ordered.forEach(n => {
        const k = (n.key || n.field_name || '').toLowerCase();
        if (k.includes('supplier') || k.includes('vendor') || k.includes('creditor')) {
          if (n.value) supplierNames.add(n.value);
        }
      });
      let supplierDatalistId = null;
      if (supplierNames.size) {
        supplierDatalistId = 'supplier-suggest';
        let dl = document.getElementById(supplierDatalistId);
        if (!dl) {
          dl = document.createElement('datalist');
          dl.id = supplierDatalistId;
          document.body.appendChild(dl);
        }
        dl.innerHTML = '';
        supplierNames.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v;
          dl.appendChild(opt);
        });
      }
	      ordered.forEach((f, idx) => {
	        const div = document.createElement('div');
	        div.className = 'field-wrap';
	        div.style.padding = '8px';
	        div.style.border = '1px solid var(--border)';
	        div.style.borderRadius = '10px';
	        div.style.background = 'var(--panel)';
	        const bbox = f.BoundingBox || f.boundingBox || f.value_box || f.box;
	        const fieldKey = f.key || f.field_name || 'Field ' + idx;
	        const displayKey = fieldAliases[fieldKey] || fieldKey;
	        const conf = normalizeConfidence(f.confidence ?? f.gptConfidence);
	        const color = confidenceColor(conf);
        const validation = f.validation || {};
        let badge = '';
        if (validation.status === 'match') {
          badge = `<span class="pill green" style="margin-left:6px;">ref</span>`;
        }
	        const requiredBadge = requiredSet.has(lower(fieldKey)) ? `<span class="pill amber" style="margin-left:6px;">required</span>` : '';
	        div.innerHTML = `
	          <label>${displayKey}${badge}${requiredBadge}</label>
	          <input data-field="${fieldKey}" data-left="${bbox && bbox.Left != null ? bbox.Left : ''}" data-top="${bbox && bbox.Top != null ? bbox.Top : ''}" data-width="${bbox && bbox.Width != null ? bbox.Width : ''}" data-height="${bbox && bbox.Height != null ? bbox.Height : ''}" value="${f.value || ''}">
	          <div class="field-error"></div>
	        `;
	        fieldsWrap.appendChild(div);
	        const inputEl = div.querySelector('input');
	        if (supplierDatalistId && fieldKey.toLowerCase().includes('supplier')) {
	          inputEl.setAttribute('list', supplierDatalistId);
	        }
	        inputEl.dataset.baseBorder = color;
	        inputEl.dataset.baseShadow = `0 0 0 1px ${color}33`;
	        inputEl.style.border = `2px solid ${color}`;
	        inputEl.style.boxShadow = inputEl.dataset.baseShadow;
	        inputEl.addEventListener('input', () => {
	          const meta = getFieldMeta(fieldKey);
	          meta.locked = true;
	          scheduleValidate();
	        });
	        if (isValidBox(bbox)) {
	          inputEl.addEventListener('focus', () => handleFieldFocus(bbox));
	          inputEl.addEventListener('click', () => handleFieldFocus(bbox));
	        }
	      });
      if (!ordered.length) {
        fieldsWrap.innerHTML = '<div>No normalized_data</div>';
      }

		      const pdfUrl = internalPdf || state.selectedDoc.pdf_url;
		      renderPdfOverlay(pdfUrl, ordered);
		      lookupDocExport();
		      autofillFromCustomerId();
		      scheduleValidate();
		    }

    function scrollToBoundingBox(box) {
      const container = document.getElementById('pdfContainer');
      const viewport = pdfRenderState.pageViewport;
      if (!container || !viewport || !isValidBox(box)) return;
      const leftPx = (box.Left || 0) * viewport.width;
      const topPx = (box.Top || 0) * viewport.height;
      const widthPx = (box.Width || 0) * viewport.width;
      const heightPx = (box.Height || 0) * viewport.height;
      container.scrollLeft = Math.max(0, leftPx - (container.clientWidth / 2) + (widthPx / 2));
      container.scrollTop = Math.max(0, topPx - (container.clientHeight / 2) + (heightPx / 2));
    }

    function zoomToBoundingBox(box) {
      if (!isValidBox(box)) return;
      const container = document.getElementById('pdfContainer');
      const viewport = pdfRenderState.pageViewport;
      let targetScale = pdfRenderState.scale;
      if (container && viewport && box.Width && box.Height) {
        const boxWidthPx = (box.Width || 0.01) * viewport.width;
        const boxHeightPx = (box.Height || 0.01) * viewport.height;
        const scaleW = (container.clientWidth * 0.8) / Math.max(boxWidthPx, 1);
        const scaleH = (container.clientHeight * 0.8) / Math.max(boxHeightPx, 1);
        const desired = Math.min(scaleW, scaleH) * 1.2; // zoom in tighter than before
        targetScale = Math.min(4.0, Math.max(targetScale, desired, 1.5));
      }
      targetScale = Math.max(0.5, targetScale);
      pdfRenderState.scale = targetScale;
      pdfRenderState.focusBox = box;
      pdfRenderState.highlightBox = box;
      renderPdfOverlay(pdfRenderState.url, pdfRenderState.norm);
    }

    function handleFieldFocus(bbox) {
      if (!isValidBox(bbox)) return;
      zoomToBoundingBox(bbox);
    }

    function fitScaleForContainer(container, baseViewport) {
      if (!container || !baseViewport) return 1;
      const pad = 24; // allow room for borders/scrollbar
      const w = Math.max(1, container.clientWidth - pad);
      const fit = w / Math.max(1, baseViewport.width);
      return Math.min(3, Math.max(0.5, fit));
    }

    async function renderPdfOverlay(url, norm) {
      const canvas = document.getElementById('pdfCanvas');
      const overlay = document.getElementById('pdfOverlay');
      overlay.innerHTML = '';

      if (!url || !window.pdfjsLib) {
        overlay.innerHTML = '<div style="padding:12px;color:var(--muted);">No PDF to display</div>';
        return;
      }

      const container = document.getElementById('pdfContainer');
      const prevUrl = pdfRenderState.url;
      const urlChanged = prevUrl !== url;
      const thisRender = ++pdfRenderState.renderId;
      pdfRenderState.url = url;
      pdfRenderState.norm = norm || [];

      try {
        // New PDF URL => load once and cache pdf/page.
        if (urlChanged || !pdfRenderState.pdf) {
          if (pdfRenderState.renderTask) {
            try { pdfRenderState.renderTask.cancel(); } catch (_) {}
            pdfRenderState.renderTask = null;
          }
          if (pdfRenderState.loadingTask) {
            try { await pdfRenderState.loadingTask.destroy(); } catch (_) {}
            pdfRenderState.loadingTask = null;
          }
          pdfRenderState.pdf = null;
          pdfRenderState.page = null;
          pdfRenderState.baseViewport = null;
          pdfRenderState.focusBox = null;
          pdfRenderState.highlightBox = null;

          overlay.innerHTML = '<div style="padding:12px;color:var(--muted);">Loading PDF…</div>';

          pdfRenderState.loadingTask = window.pdfjsLib.getDocument({
            url,
            withCredentials: false,
            httpHeaders: state.token ? { 'Authorization': 'Bearer ' + state.token } : {},
            isEvalSupported: false,
            disableRange: true,
          });
          const pdf = await pdfRenderState.loadingTask.promise;
          if (thisRender !== pdfRenderState.renderId) return;
          pdfRenderState.pdf = pdf;
          pdfRenderState.page = await pdf.getPage(1);
          if (thisRender !== pdfRenderState.renderId) return;
          pdfRenderState.baseViewport = pdfRenderState.page.getViewport({ scale: 1 });
          pdfRenderState.scale = fitScaleForContainer(container, pdfRenderState.baseViewport);
        }

        if (!pdfRenderState.page) {
          overlay.innerHTML = '<div style="padding:12px;color:var(--danger);">PDF render error: page not available</div>';
          return;
        }

        const viewport = pdfRenderState.page.getViewport({ scale: pdfRenderState.scale });
        pdfRenderState.pageViewport = viewport;
        const ctx = canvas.getContext('2d');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        canvas.style.width = viewport.width + 'px';
        canvas.style.height = viewport.height + 'px';

        if (pdfRenderState.renderTask) {
          try { pdfRenderState.renderTask.cancel(); } catch (_) {}
          pdfRenderState.renderTask = null;
        }
        pdfRenderState.renderTask = pdfRenderState.page.render({ canvasContext: ctx, viewport });
        await pdfRenderState.renderTask.promise;
        if (thisRender !== pdfRenderState.renderId) return;

        overlay.style.width = viewport.width + 'px';
        overlay.style.height = viewport.height + 'px';
        overlay.style.pointerEvents = 'none';
        overlay.innerHTML = '';
        if (pdfRenderState.highlightBox && isValidBox(pdfRenderState.highlightBox)) {
          const hb = pdfRenderState.highlightBox;
          const left = (hb.Left || 0) * viewport.width;
          const top = (hb.Top || 0) * viewport.height;
          const width = (hb.Width || 0) * viewport.width;
          const height = (hb.Height || 0) * viewport.height;
          const hl = document.createElement('div');
          hl.style.position = 'absolute';
          hl.style.left = `${left}px`;
          hl.style.top = `${top}px`;
          hl.style.width = `${width}px`;
          hl.style.height = `${height}px`;
          hl.style.border = `2px solid ${confidenceColor(0.8)}`;
          hl.style.background = '#60a5fa33';
          hl.style.pointerEvents = 'none';
          overlay.appendChild(hl);
        }

        if (pdfRenderState.focusBox) {
          scrollToBoundingBox(pdfRenderState.focusBox);
          pdfRenderState.focusBox = null;
        }
      } catch (err) {
        overlay.innerHTML = `<div style="padding:12px;color:var(--danger);">PDF render error: ${err}</div><div style="padding:6px;color:var(--muted);word-break:break-all;">${url || 'No PDF URL'}</div>`;
      }
    }

    // Zoom controls: bind once so they still work even if a render fails mid-way.
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    if (zoomInBtn) {
      zoomInBtn.addEventListener('click', () => {
        if (!pdfRenderState.url) return;
        pdfRenderState.scale = Math.min(pdfRenderState.scale + 0.1, 4);
        pdfRenderState.focusBox = null;
        renderPdfOverlay(pdfRenderState.url, pdfRenderState.norm);
      });
    }
    if (zoomOutBtn) {
      zoomOutBtn.addEventListener('click', () => {
        if (!pdfRenderState.url) return;
        pdfRenderState.scale = Math.max(pdfRenderState.scale - 0.1, 0.5);
        pdfRenderState.focusBox = null;
        renderPdfOverlay(pdfRenderState.url, pdfRenderState.norm);
      });
    }

    // Re-fit the PDF to the container on resize (only when not zoomed in).
    window.addEventListener('resize', () => {
      const container = document.getElementById('pdfContainer');
      if (!pdfRenderState.url || !pdfRenderState.baseViewport || !container) return;
      if (pdfRenderState.scale <= 1.05) {
        pdfRenderState.scale = fitScaleForContainer(container, pdfRenderState.baseViewport);
        renderPdfOverlay(pdfRenderState.url, pdfRenderState.norm);
      }
    });

    async function requestUploadUrl(folder, filename, contentType) {
      return api('/api/upload-url', {
        method: 'POST',
        body: JSON.stringify({ folder, filename, content_type: contentType })
      });
    }

    async function putFile(url, file) {
      const resp = await fetch(url, { method: 'PUT', headers: { 'Content-Type': file.type || 'application/pdf' }, body: file });
      if (!resp.ok) throw new Error('PUT failed: ' + resp.status);
    }

    async function pollTextract() {
      if (!state.current.filename) return;
      const params = new URLSearchParams({ folder: state.current.folder, filename: state.current.filename });
      try {
        const data = await api('/api/textract?' + params.toString(), { method: 'GET' });
        if (data.status === 'ready') {
          textractCard.classList.remove('hidden');
          textractStatus.innerHTML = `<span class="pill green">Ready</span> <code>${data.key}</code>`;
          renderTextract(data.data || {});
          lookupExport();
          clearInterval(state.polling);
          state.polling = null;
        } else {
          textractCard.classList.remove('hidden');
          textractStatus.innerHTML = `<span class="pill amber">Processing</span>`;
        }
      } catch (e) {
        textractStatus.textContent = 'Status error: ' + e.message;
      }
    }

	    async function lookupExport() {
	      const params = new URLSearchParams({ folder: state.current.folder, filename: state.current.filename });
	      try {
	        const data = await api('/api/export?' + params.toString(), { method: 'GET' });
	        if (data.status === 'ready' && data.url) {
	          exportLink.innerHTML = `<a href="${data.url}" target="_blank">Download ZIP</a>`;
	        } else {
	          exportLink.innerHTML = '';
	        }
	      } catch (_) {}
	    }

	    async function lookupDocExport() {
	      if (!docExportStatus) return;
	      if (!state.selectedDoc) { docExportStatus.textContent = 'No document selected'; return; }
	      const srcKey = state.selectedDoc.source_file || (state.selectedDoc.payload && state.selectedDoc.payload.source_file) || '';
	      if (!srcKey) { docExportStatus.textContent = 'No source file'; return; }
	      try {
	        const qs = new URLSearchParams({ key: srcKey });
	        const data = await api('/api/export?' + qs.toString(), { method: 'GET' });
	        if (data.status === 'ready' && data.url) {
	          docExportStatus.innerHTML = `<span class="pill green">Ready</span> <a href="${data.url}" target="_blank">Download ZIP</a> <span style="color:var(--muted);">${data.key || ''}</span>`;
	        } else {
	          docExportStatus.innerHTML = `<span class="pill amber">Not generated</span>`;
	        }
	      } catch (e) {
	        docExportStatus.textContent = 'Export lookup error: ' + e.message;
	      }
	    }

    function renderTextract(json) {
      rawJson.textContent = JSON.stringify(json, null, 2);
      const normalized = json.normalized_data || [];
      if (!normalized.length) {
        textractData.innerHTML = '<p>normalized_data is empty</p>';
        return;
      }
      let html = '<table><thead><tr><th>Field</th><th>Value</th><th>Confidence</th></tr></thead><tbody>';
      for (const row of normalized) {
        const c = colorPill(row.confidence || 0);
        html += `<tr><td>${row.key || ''}</td><td>${row.value || ''}</td><td><span class="pill ${c}">${(row.confidence || 0).toFixed(2)}</span></td></tr>`;
      }
      html += '</tbody></table>';
      textractData.innerHTML = html;
    }

    uploadBtn.addEventListener('click', async () => {
      if (!state.selectedJob) { alert('Select a job first'); return; }
      const files = Array.from(fileInput.files || []);
      if (!files.length) { alert('Select file(s)'); return; }
      const folder = state.selectedJob.folder_prefix || '';
      try {
        uploadBtn.disabled = true;
        statusBox.textContent = `Uploading ${files.length} file(s)...`;
        let lastKey = null;
        let lastName = null;
        for (const file of files) {
          statusBox.textContent = `Requesting URL for ${file.name}...`;
          const presign = await requestUploadUrl(folder, file.name, file.type || 'application/pdf');
          statusBox.textContent = `Uploading ${file.name}...`;
          await putFile(presign.uploadUrl, file);
          lastKey = presign.key;
          lastName = file.name;
        }
        statusBox.textContent = 'Upload complete. Waiting for Textract...';
        if (lastKey && lastName) {
          state.current = { folder, filename: lastName, key: lastKey };
          if (state.polling) clearInterval(state.polling);
          pollTextract();
          state.polling = setInterval(pollTextract, 6000);
        }
      } catch (err) {
        statusBox.textContent = 'Error: ' + err.message;
      } finally {
        uploadBtn.disabled = false;
      }
    });

    document.getElementById('refreshDocsBtn').addEventListener('click', () => refreshDocs(true));
    document.getElementById('docStatusFilter').addEventListener('change', () => refreshDocs(true));
    const groupBySel = document.getElementById('docGroupBy');
    const groupDateInput = document.getElementById('groupDateInput');
    const groupControls = document.getElementById('groupPeriodControls');
    const groupPrev = document.getElementById('groupPrev');
    const groupNext = document.getElementById('groupNext');
    function applyGroupMode(mode) {
      state.groupMode = mode;
      localStorage.setItem('docGroupMode', mode);
        if (groupControls) groupControls.classList.toggle('hidden', mode === 'none');
        if (mode !== 'none' && !state.groupDate) {
        state.groupDate = new Date().toISOString().slice(0,10);
        localStorage.setItem('docGroupDate', state.groupDate);
      }
      if (groupDateInput) groupDateInput.value = state.groupDate || '';
      renderDocs();
    }
    if (groupBySel) {
      groupBySel.addEventListener('change', (e) => applyGroupMode(e.target.value));
    }
    if (groupDateInput) {
      groupDateInput.addEventListener('change', (e) => {
        state.groupDate = e.target.value;
        localStorage.setItem('docGroupDate', state.groupDate);
        renderDocs();
      });
    }
    function shiftPeriod(dir) {
      if (!state.groupMode || state.groupMode === 'none') return;
      const base = state.groupDate ? new Date(state.groupDate) : new Date();
      if (isNaN(base.getTime())) return;
      if (state.groupMode === 'day') {
        base.setUTCDate(base.getUTCDate() + dir);
      } else if (state.groupMode === 'month') {
        base.setUTCMonth(base.getUTCMonth() + dir);
      }
      state.groupDate = base.toISOString().slice(0,10);
      localStorage.setItem('docGroupDate', state.groupDate);
      if (groupDateInput) groupDateInput.value = state.groupDate;
      renderDocs();
    }
    if (groupPrev) groupPrev.addEventListener('click', () => shiftPeriod(-1));
    if (groupNext) groupNext.addEventListener('click', () => shiftPeriod(1));

	    docDetailCard.querySelector('#docSaveBtn').addEventListener('click', async () => {
      if (!state.selectedDoc) return;
      try {
        const statusSel = docDetailCard.querySelector('#docStatusSelect');
        const inputs = docDetailCard.querySelectorAll('input[data-field]');
        const fields = Array.from(inputs).map(i => ({ field_name: i.dataset.field, value: i.value }));
        const reasonVal = statusSel.value === 'Rejected' && docReasonSelect ? docReasonSelect.value : '';
        const currentKey = state.selectedDoc.key;
	        await api('/api/documents', {
	          method: 'PATCH',
	          body: JSON.stringify({ key: state.selectedDoc.key, status: statusSel.value, reason: reasonVal, fields })
		    });
	        await refreshDocs(true);
	        const nextDoc = findNextToReview(currentKey);
	        if (nextDoc) {
	          openDoc(nextDoc);
        } else {
          state.selectedDoc = null;
          docDetailCard.classList.add('hidden');
          alert('Saved. No more documents To Review.');
        }
	      } catch (e) {
	        try {
	          const detail = e && e.data && e.data.detail;
	          if (detail && typeof detail === 'object' && Array.isArray(detail.errors)) {
	            renderValidationErrors(detail.errors);
	          } else {
	            await validateSelectedDoc();
	          }
	        } catch (_) {}
	        alert('Save error: ' + e.message);
	      }
	    });

    createUserBtn.addEventListener('click', async () => {
      try {
        usersStatus.textContent = 'Creating...';
        await api('/admin/users', {
          method: 'POST',
          body: JSON.stringify({ email: userEmail.value, password: userPass.value, role: userRole.value })
        });
        usersStatus.textContent = 'User created';
        refreshUsers();
      } catch (e) {
        usersStatus.textContent = 'Error: ' + e.message;
      }
    });

    createAccessBtn.addEventListener('click', async () => {
      try {
        const userId = parseInt(accessUserSelect.value, 10);
        if (!userId) { accessStatus.textContent = 'Select user'; return; }
        const selected = Array.from(accessFoldersWrap.querySelectorAll('input[type=checkbox]:checked')).map(i => i.value);
        accessStatus.textContent = 'Saving...';
        await api('/admin/access/bulk', {
          method: 'POST',
          body: JSON.stringify({ user_id: userId, folders: selected })
        });
        accessStatus.textContent = 'Access updated';
        refreshAccess();
      } catch (e) {
        accessStatus.textContent = 'Error: ' + e.message;
      }
    });

    async function refreshUsers() {
      if (state.role !== 'admin') { usersStatus.textContent = 'No permission'; return; }
      try {
        const users = await api('/admin/users');
        usersTableBody.innerHTML = '';
        for (const u of users) {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${u.email}</td><td>${u.role}</td><td>${u.created_at}</td><td>${u.id !==  state.user?.id ? '<button class="secondary" data-id="'+u.id+'">Delete</button>' : ''}</td>`;
          const btn = tr.querySelector('button');
          if (btn) {
            btn.addEventListener('click', async () => {
              if (!confirm('Delete user?')) return;
              try {
                await api('/admin/users/' + u.id, { method: 'DELETE' });
                refreshUsers();
                refreshAccess();
              } catch (e) {
                alert('Delete failed: ' + e.message);
              }
            });
          }
          usersTableBody.appendChild(tr);
        }
        usersStatus.textContent = `${users.length} users`;
        renderAccessUserOptions(users);
      } catch (e) {
        usersStatus.textContent = 'Error: ' + e.message;
      }
    }

    async function refreshAccess() {
      if (state.role !== 'admin') { accessStatus.textContent = 'No permission'; return; }
      try {
        const rows = await api('/admin/access');
        state.userAccess = rows;
        accessTableBody.innerHTML = '';
        for (const r of rows) {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${r.id}</td><td>${r.user_id}</td><td>${r.folder_prefix}</td><td><button class="secondary" data-id="${r.id}">Delete</button></td>`;
          tr.querySelector('button').addEventListener('click', async () => {
            try {
              await api('/admin/access/' + r.id, { method: 'DELETE' });
              refreshAccess();
            } catch (e) {
              alert('Delete failed: ' + e.message);
            }
          });
          accessTableBody.appendChild(tr);
        }
        accessStatus.textContent = `${rows.length} access records`;
        renderAccessFolders();
      } catch (e) {
        accessStatus.textContent = 'Error: ' + e.message;
      }
    }

	    createJobBtn.addEventListener('click', async () => {
	      try {
	        jobsAdminStatus.textContent = 'Creating...';
	        await api('/admin/jobs', {
	          method: 'POST',
	          body: JSON.stringify({
	            customer: jobCustomer.value,
	            name: jobName.value,
	            job_type: jobType.value,
	            priority: parseInt(jobPriority.value || '0', 10),
	            folder_prefix: jobFolderPrefix.value,
	            active_verifiers: parseInt(jobVerifiers.value || '0', 10),
	          })
	        });
	        jobsAdminStatus.textContent = 'Job created';
	        await refreshJobs();
	        renderAccessFolders();
	      } catch (e) {
	        jobsAdminStatus.textContent = 'Error: ' + e.message;
	      }
	    });

	    async function adminLoadJobConfig() {
	      if (state.role !== 'admin') return;
	      const job = (jobConfigPrefix && jobConfigPrefix.value || '').trim();
	      if (!job) { if (jobConfigStatus) jobConfigStatus.textContent = 'Enter job prefix'; return; }
	      try {
	        if (jobConfigStatus) jobConfigStatus.textContent = 'Loading...';
	        const data = await api('/api/job-config?job=' + encodeURIComponent(job), { method: 'GET' });
	        const cfg = (data && data.config && typeof data.config === 'object') ? data.config : {};
	        if (jobConfigJson) jobConfigJson.value = JSON.stringify(cfg, null, 2);
	        if (jobConfigStatus) jobConfigStatus.textContent = 'Loaded';
	      } catch (e) {
	        if (jobConfigStatus) jobConfigStatus.textContent = 'Error: ' + e.message;
	      }
	    }

	    async function adminSaveJobConfig() {
	      if (state.role !== 'admin') return;
	      const job = (jobConfigPrefix && jobConfigPrefix.value || '').trim();
	      if (!job) { if (jobConfigStatus) jobConfigStatus.textContent = 'Enter job prefix'; return; }
	      let cfg = {};
	      try {
	        cfg = JSON.parse((jobConfigJson && jobConfigJson.value) || '{}');
	      } catch (e) {
	        if (jobConfigStatus) jobConfigStatus.textContent = 'JSON parse error: ' + e.message;
	        return;
	      }
	      try {
	        if (jobConfigStatus) jobConfigStatus.textContent = 'Saving...';
	        await api('/admin/job-config', { method: 'POST', body: JSON.stringify({ job, config: cfg }) });
	        if (jobConfigStatus) jobConfigStatus.textContent = 'Saved';
	        if (state.selectedJob && state.selectedJob.folder_prefix === job) {
	          await loadJobConfig(job);
	          renderDocDetail();
	        }
	      } catch (e) {
	        if (jobConfigStatus) jobConfigStatus.textContent = 'Error: ' + e.message;
	      }
	    }

	    if (jobConfigLoadBtn) jobConfigLoadBtn.addEventListener('click', adminLoadJobConfig);
	    if (jobConfigSaveBtn) jobConfigSaveBtn.addEventListener('click', adminSaveJobConfig);

	    // Access matrix summary
	    const accessSummaryTableBody = document.createElement('tbody');
	    function renderAccessSummary() {
	      const table = document.getElementById('accessSummaryTable');
      if (!table) return;
      table.querySelector('tbody').replaceWith(accessSummaryTableBody);
    }
		    async function refreshAccessSummary() {
	      const statusEl = document.getElementById('accessSummaryStatus');
	      if (statusEl) statusEl.textContent = 'Loading...';
	      try {
	        const data = await api('/admin/access/summary');
	        accessSummaryTableBody.innerHTML = '';
	        data.forEach(row => {
	          const tr = document.createElement('tr');
	          tr.innerHTML = `<td>${row.email}</td><td>${row.role}</td><td>${row.jobs.join(', ')}</td>`;
	          accessSummaryTableBody.appendChild(tr);
	        });
	        if (statusEl) statusEl.textContent = `${data.length} users`;
	        renderAccessSummary();
	      } catch (e) {
	        if (statusEl) statusEl.textContent = 'Error: ' + e.message;
		      }
		    }

		    async function refreshAutomation() {
		      if (state.role !== 'admin') return;
		      if (automationStatus) automationStatus.textContent = 'Loading...';
		      try {
		        const cfg = await api('/api/automation', { method: 'GET' });
		        const enabled = !!(cfg && cfg.enabled);
		        if (automationEnabled) automationEnabled.value = enabled ? 'true' : 'false';
		        const updated = (cfg && cfg.updated_at) ? ` | updated: ${cfg.updated_at}` : '';
		        const by = (cfg && cfg.updated_by) ? ` | by: ${cfg.updated_by}` : '';
		        if (automationStatus) automationStatus.textContent = `Automation ${enabled ? 'ENABLED' : 'DISABLED'}${updated}${by}`;
		      } catch (e) {
		        if (automationStatus) automationStatus.textContent = 'Error: ' + e.message;
		      }
		    }
		    async function saveAutomation() {
		      if (state.role !== 'admin') return;
		      try {
		        if (automationStatus) automationStatus.textContent = 'Saving...';
		        const enabled = (automationEnabled && automationEnabled.value === 'true');
		        await api('/admin/automation', { method: 'POST', body: JSON.stringify({ enabled }) });
		        await refreshAutomation();
		      } catch (e) {
		        if (automationStatus) automationStatus.textContent = 'Error: ' + e.message;
		      }
		    }
		    if (automationRefreshBtn) automationRefreshBtn.addEventListener('click', refreshAutomation);
		    if (automationSaveBtn) automationSaveBtn.addEventListener('click', saveAutomation);

		    async function runMonthlyReport() {
		      if (state.role !== 'admin') return;
		      const month = (reportMonth && reportMonth.value) ? reportMonth.value : new Date().toISOString().slice(0, 7);
		      const job = (reportJobPrefix && reportJobPrefix.value || '').trim();
		      if (reportStatus) reportStatus.textContent = 'Loading...';
		      if (reportTableBody) reportTableBody.innerHTML = '';
		      try {
		        const qs = new URLSearchParams({ month });
		        if (job) qs.append('job', job);
		        const data = await api('/api/reports/monthly?' + qs.toString(), { method: 'GET' });
		        const jobs = (data && Array.isArray(data.jobs)) ? data.jobs : [];
		        const totals = data && data.totals ? data.totals : null;
		        state.reportData = { month: (data && data.month) ? data.month : month, jobs, totals };
		        if (reportTableBody) {
		          jobs.forEach(r => {
		            const by = r.by_status || {};
		            const tr = document.createElement('tr');
		            tr.innerHTML = `<td>${r.job || ''}</td><td>${r.documents || 0}</td><td>${r.pages || 0}</td><td>${by['To Review'] || 0}</td><td>${by['Approved'] || 0}</td><td>${by['Rejected'] || 0}</td><td>${by['Hold'] || 0}</td><td>${by['Exported'] || 0}</td>`;
		            reportTableBody.appendChild(tr);
		          });
		        }
		        if (reportStatus) {
		          const td = totals ? totals.documents : 0;
		          const tp = totals ? totals.pages : 0;
		          reportStatus.textContent = `Month ${month}: ${td} documents, ${tp} pages`;
		        }
		      } catch (e) {
		        state.reportData = null;
		        if (reportStatus) reportStatus.textContent = 'Error: ' + e.message;
		      }
		    }
		    if (runReportBtn) runReportBtn.addEventListener('click', runMonthlyReport);

		    function downloadMonthlyReportCsv() {
		      if (!state.reportData || !Array.isArray(state.reportData.jobs)) {
		        alert('Run report first');
		        return;
		      }
		      const month = state.reportData.month || '';
		      const rows = state.reportData.jobs || [];
		      const header = ['month','job','customer','job_type','documents','pages','to_review','approved','rejected','hold','exported'];
		      const lines = [header.join(',')];
		      rows.forEach(r => {
		        const by = r.by_status || {};
		        const vals = [
		          month,
		          r.job || '',
		          r.customer || '',
		          r.job_type || '',
		          String(r.documents || 0),
		          String(r.pages || 0),
		          String(by['To Review'] || 0),
		          String(by['Approved'] || 0),
		          String(by['Rejected'] || 0),
		          String(by['Hold'] || 0),
		          String(by['Exported'] || 0),
		        ].map(v => `"${String(v).replaceAll('"','""')}"`);
		        lines.push(vals.join(','));
		      });
		      const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8' });
		      const url = URL.createObjectURL(blob);
		      const a = document.createElement('a');
		      a.href = url;
		      a.download = `monthly_report_${month || 'unknown'}.csv`;
		      document.body.appendChild(a);
		      a.click();
		      a.remove();
		      URL.revokeObjectURL(url);
		    }
			    if (downloadReportCsvBtn) downloadReportCsvBtn.addEventListener('click', downloadMonthlyReportCsv);

			    async function runBilling() {
			      if (state.role !== 'admin') return;
			      const month = (billingMonth && billingMonth.value) ? billingMonth.value : new Date().toISOString().slice(0, 7);
			      const job = (billingJobPrefix && billingJobPrefix.value || '').trim();
			      if (billingStatus) billingStatus.textContent = 'Loading...';
			      if (billingTableBody) billingTableBody.innerHTML = '';
			      try {
			        const qs = new URLSearchParams({ month });
			        if (job) qs.append('job', job);
			        const data = await api('/api/billing/monthly?' + qs.toString(), { method: 'GET' });
			        const groups = (data && Array.isArray(data.groups)) ? data.groups : [];
			        const totals = data && data.totals ? data.totals : null;
			        state.billingData = { month: (data && data.month) ? data.month : month, groups, totals };
			        if (billingTableBody) {
			          groups.forEach(g => {
			            const by = g.by_status || {};
			            const tr = document.createElement('tr');
			            tr.innerHTML = `<td>${g.customer || ''}</td><td>${g.job_type || ''}</td><td>${(g.jobs || []).join(', ')}</td><td>${g.documents || 0}</td><td>${g.pages || 0}</td><td>${by['To Review'] || 0}</td><td>${by['Approved'] || 0}</td><td>${by['Rejected'] || 0}</td><td>${by['Hold'] || 0}</td><td>${by['Exported'] || 0}</td>`;
			            billingTableBody.appendChild(tr);
			          });
			        }
			        if (billingStatus) {
			          const td = totals ? totals.documents : 0;
			          const tp = totals ? totals.pages : 0;
			          billingStatus.textContent = `Month ${month}: ${td} documents, ${tp} pages (grouped by customer/job type)`;
			        }
			      } catch (e) {
			        state.billingData = null;
			        if (billingStatus) billingStatus.textContent = 'Error: ' + e.message;
			      }
			    }
			    if (runBillingBtn) runBillingBtn.addEventListener('click', runBilling);

			    async function downloadBillingCsv() {
			      if (state.role !== 'admin') return;
			      const month = (billingMonth && billingMonth.value) ? billingMonth.value : new Date().toISOString().slice(0, 7);
			      const job = (billingJobPrefix && billingJobPrefix.value || '').trim();
			      try {
			        const qs = new URLSearchParams({ month });
			        if (job) qs.append('job', job);
			        const resp = await fetch('/api/billing/export?' + qs.toString(), {
			          method: 'GET',
			          headers: state.token ? { 'Authorization': 'Bearer ' + state.token } : {}
			        });
			        if (!resp.ok) throw new Error(await resp.text());
			        const blob = await resp.blob();
			        const url = URL.createObjectURL(blob);
			        const a = document.createElement('a');
			        a.href = url;
			        a.download = `billing_${month || 'unknown'}.csv`;
			        document.body.appendChild(a);
			        a.click();
			        a.remove();
			        URL.revokeObjectURL(url);
			      } catch (e) {
			        alert('Billing export failed: ' + e.message);
			      }
			    }
			    if (downloadBillingCsvBtn) downloadBillingCsvBtn.addEventListener('click', downloadBillingCsv);

		    function initFromStorage() {
		      const savedTheme = localStorage.getItem('theme') || 'dark';
		      setTheme(savedTheme);
		      if (state.token) {
        setUserInfo();
        showView('jobs');
        refreshJobs();
        refreshUsers();
        refreshAccess();
        setCollapsed('upload', true);
        setCollapsed('docs', true);
        setCollapsed('jobsList', false);
        if (jobContext) { jobContext.classList.add('hidden'); jobContext.textContent = ''; }
        if (docsJobLabel) { docsJobLabel.textContent = ''; }
        const gb = document.getElementById('docGroupBy');
        if (gb) gb.value = state.groupMode || 'none';
		        const gdi = document.getElementById('groupDateInput');
		        if (gdi) gdi.value = state.groupDate || '';
		        if (reportMonth && !reportMonth.value) reportMonth.value = new Date().toISOString().slice(0, 7);
		        if (billingMonth && !billingMonth.value) billingMonth.value = new Date().toISOString().slice(0, 7);
		      } else {
		        showView('login');
		      }
		    }

    setUserInfo();
    initFromStorage();
    document.querySelectorAll('[data-toggle]').forEach(btn => {
      btn.addEventListener('click', () => {
        const name = btn.getAttribute('data-toggle');
        const body = document.querySelector(`[data-collapsible="${name}"] .collapsible-body`);
        const isCollapsed = body && body.classList.contains('collapsed');
        setCollapsed(name, !isCollapsed);
      });
    });
    layoutButtons.forEach(btn => {
      btn.addEventListener('click', () => setLayout(btn.getAttribute('data-layout')));
    });
    const refreshSummaryBtn = document.getElementById('refreshAccessSummaryBtn');
    if (refreshSummaryBtn) {
      refreshSummaryBtn.addEventListener('click', refreshAccessSummary);
    }
    renderAccessSummary();

		    async function downloadExport(status) {
		      if (!state.selectedJob) { alert('Select a job first'); return; }
		      try {
		        const markExported = (status === 'Approved' || status === 'Rejected');
		        const res = await api('/api/export/batch/s3', {
		          method: 'POST',
		          body: JSON.stringify({ job: state.selectedJob.folder_prefix, status, upload_ftp: false, mark_exported: markExported })
		        });
	        const url = res.url;
	        if (!url) throw new Error('Missing export URL');
	        const a = document.createElement('a');
	        a.href = url;
	        a.download = `export_${state.selectedJob.folder_prefix}_${status || 'all'}.zip`;
	        document.body.appendChild(a);
	        a.click();
	        a.remove();
	        await refreshDocs(true);
	      } catch (e) {
	        alert('Export failed: ' + e.message);
	      }
	    }
	    const exportApprovedBtn = document.getElementById('exportApprovedBtn');
	    const exportRejectedBtn = document.getElementById('exportRejectedBtn');
	    const exportHoldBtn = document.getElementById('exportHoldBtn');
	    if (exportApprovedBtn) exportApprovedBtn.addEventListener('click', () => downloadExport('Approved'));
	    if (exportRejectedBtn) exportRejectedBtn.addEventListener('click', () => downloadExport('Rejected'));
	    if (exportHoldBtn) exportHoldBtn.addEventListener('click', () => downloadExport('Hold'));

	    async function runCustomerLookup() {
	      if (!customerLookupInput || !customerLookupInput.value.trim()) return;
	      try {
	        if (customerLookupStatus) customerLookupStatus.textContent = 'Searching...';
	        const cid = customerLookupInput.value.trim();
	        const qs = new URLSearchParams({ customer_id: cid });
	        const res = await api('/api/customers/lookup?' + qs.toString());
	        if (!res.found || res.status !== 'match' || !res.selected) {
	          if (customerLookupStatus) customerLookupStatus.textContent = `Not found for ${cid}`;
	          if (res && res.status === 'ambiguous') {
	            const c = res.match_count || (res.data ? res.data.length : 0);
	            if (customerLookupStatus) customerLookupStatus.textContent = `Ambiguous for ${cid} (${c} matches)`;
	          }
	          return;
	        }
	        const match = res.selected;
	        if (customerLookupStatus) customerLookupStatus.textContent = `Found ${match.name || ''} (${match.customer_id})`;
	        // populate fields
	        const inputs = docDetailCard.querySelectorAll('input[data-field]');
	        inputs.forEach(inp => {
	          const key = (inp.dataset.field || '').toLowerCase();
	          const meta = getFieldMeta(inp.dataset.field || '');
	          if (meta.locked) return;
	          if (key.includes('supplier') || key.includes('creditor')) {
	            if (match.name) inp.value = match.name;
	            if (key.includes('code') && match.customer_id) inp.value = match.customer_id;
	          }
	          if (key.includes('gst') && match.gst_abn) {
	            inp.value = match.gst_abn;
	          }
	        });
	        scheduleValidate();
	      } catch (e) {
	        if (customerLookupStatus) customerLookupStatus.textContent = 'Lookup error: ' + e.message;
	      }
	    }
    if (customerLookupBtn) customerLookupBtn.addEventListener('click', runCustomerLookup);
    if (customerLookupInput) {
      customerLookupInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          runCustomerLookup();
        }
      });
    }
    async function uploadReference() {
      if (!refUploadInput || !refUploadInput.files.length) { alert('Select a CSV'); return; }
      const file = refUploadInput.files[0];
      const form = new FormData();
      form.append('file', file);
      if (refStatus) refStatus.textContent = 'Uploading...';
      try {
        const resp = await fetch('/admin/reference/upload', {
          method: 'POST',
          body: form,
          headers: state.token ? { 'Authorization': 'Bearer ' + state.token } : {}
        });
        if (!resp.ok) throw new Error(await resp.text());
        const data = await resp.json();
        if (refStatus) refStatus.textContent = `Uploaded ${data.file}, suppliers: ${data.suppliers}`;
      } catch (e) {
        if (refStatus) refStatus.textContent = 'Upload error: ' + e.message;
      }
    }
    async function reloadReference() {
      if (refStatus) refStatus.textContent = 'Reloading...';
      try {
        const resp = await api('/admin/reference/reload', { method: 'POST' });
        if (refStatus) refStatus.textContent = `Reloaded, suppliers: ${resp.suppliers}`;
      } catch (e) {
        if (refStatus) refStatus.textContent = 'Reload error: ' + e.message;
      }
    }
    async function importReferenceFromFtp() {
      if (refStatus) refStatus.textContent = 'Importing from FTP...';
      try {
        const resp = await api('/admin/reference/import-ftp', { method: 'POST' });
        const imported = (resp && Array.isArray(resp.imported)) ? resp.imported.length : 0;
        const errors = (resp && Array.isArray(resp.errors)) ? resp.errors.length : 0;
        const sup = (resp && resp.suppliers != null) ? resp.suppliers : '';
        if (refStatus) refStatus.textContent = `FTP import: ${imported} file(s), ${errors} error(s), suppliers: ${sup}`;
      } catch (e) {
        if (refStatus) refStatus.textContent = 'FTP import error: ' + e.message;
      }
    }
    if (refUploadBtn) refUploadBtn.addEventListener('click', uploadReference);
    if (refReloadBtn) refReloadBtn.addEventListener('click', reloadReference);
    if (refImportFtpBtn) refImportFtpBtn.addEventListener('click', importReferenceFromFtp);
  </script>
</body>
</html>
